# -*- coding: utf-8 -*-
# from stopwatch import clockit as _clockit
from lib.timer_laps import LapWatch as _LapWatch
import sys as _sys


def problem_001(num=1000):
    """
    If we list all the natural numbers below 10 that are multiples
    of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000.
    """
    total = 0
    for i in range(3, num):
        if _divisible_by(i, 3):
            total += i
        elif _divisible_by(i, 5):
            total += i
    return total


def problem_001_v2(num=1000):
    return sum([x for x in range(3, num) if x % 3 == 0 or x % 5 == 0])


def problem_002(max_num=4000000):
    """
    Each new term in the Fibonacci sequence is generated by adding
    the previous two terms. By starting with 1 and 2, the first 10
    terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values
    do not exceed four million, find the sum of the even-valued terms.
    """
    fib = _build_fib(max_num)
    total = 0
    for i in fib:
        if _divisible_by(i, 2):
            total += i
    return total


def problem_003(num=600851475143):
    """
    The prime factors of 13195 are 5, 7, 13 and 29.

    What is the largest prime factor of the number 600851475143 ?
    """
    all_factors = _get_factors(num)
    for i in all_factors:
        if _is_prime(i[1]):
            return i[1]
    for i in range(len(all_factors) - 1, 0, -1):
        if _is_prime(all_factors[i][0]):
            return all_factors[i][0]


def problem_004(max_num=999, min_num=100):
    """
    A palindromic number reads the same both ways. The largest palindrome
    made from the product of two 2-digit numbers is 9009 (91X99)

    Find the largest palindrome made from the product of two 3-digit numbers.
    """
    palas = []
    for i in range(max_num, min_num, -1):
        for j in range(max_num, min_num, -1):
            num_str = str(i * j)
            is_pala = True
            for k in range(0, len(num_str) / 2):
                if num_str[k] != num_str[-(k+1)]:
                    is_pala = False
                    break
            if is_pala:
                palas.append(i*j)
    return max(palas)


def problem_005(num_range=range(1, 21)):
    """
    2520 is the smallest number that can be divided by each of the
    numbers from 1 to 10 without any remainder.

    What is the smallest positive number that is evenly divisible
    by all of the numbers from 1 to 20?
    """
    highest = num_range[-1]
    result_found = False
    cnt = 1
    while not result_found:
        try_num = cnt * highest
        for i in num_range:
            if not _divisible_by(try_num, i):
                break
        else:
            return try_num
        cnt += 1


def problem_005_v2(num_range=range(1, 21)):
    pos_factor = list(num_range)
    for i in range(len(num_range)-1, 1, -1):
        temp_fact = _get_factors(num_range[i])
        for j in range(1, len(temp_fact)):
            try:
                pos_factor.remove(temp_fact[j][0])
            except:
                pass
            try:
                pos_factor.remove(temp_fact[j][1])
            except:
                pass
    pos_factor.remove(1)
    return problem_005(pos_factor)


def problem_006(max_num=100):
    """
    The sum of the squares of the first ten natural numbers is,

    12 + 22 + ... + 102 = 385
    The square of the sum of the first ten natural numbers is,

    (1 + 2 + ... + 10)2 = 552 = 3025
    Hence the difference between the sum of the squares of
    the first ten natural numbers and the square of the sum
    is 3025 − 385 = 2640.

    Find the difference between the sum of the squares of
    the first one hundred natural numbers and the square of the sum.
    """
    sum_squares = 0
    squared_sum = 0
    for i in range(1, max_num + 1):
        sum_squares += i * i
        squared_sum += i
    return (squared_sum * squared_sum) - sum_squares


def problem_006_v2(max_num=100):
    total_sum = sum(range(1, max_num+1))
    result = 0
    for i in range(1, max_num + 1):
        result += i * (total_sum - i)
    return result


def problem_007(nth_prime=10001):
    """
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
    we can see that the 6th prime is 13.

    What is the 10,001st prime number?
    """
    prime_cnt = 0
    cur_num = 2
    while prime_cnt != nth_prime:
        if _is_prime_quick(cur_num):
            prime_cnt += 1
        cur_num += 1
    return cur_num - 1


def problem_007_v2(nth_prime=10001):
    only_prime = []
    primes = _get_all_primes(int(nth_prime / 0.05))
    for prime in primes:
        if prime != 0:
            only_prime.append(prime)
    return only_prime[nth_prime - 1]


def problem_008(num_digits=13):
    """
    The four adjacent digits in the 1000-digit number that have
    the greatest product are 9 × 9 × 8 × 9 = 5832.

    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450

    Find the thirteen adjacent digits in the 1000-digit number
    that have the greatest product. What is the value of this product?
    """
    import numpy

    num_str = "73167176531330624919225119674426574742355349194934" + \
              "96983520312774506326239578318016984801869478851843" + \
              "85861560789112949495459501737958331952853208805511" + \
              "12540698747158523863050715693290963295227443043557" + \
              "66896648950445244523161731856403098711121722383113" + \
              "62229893423380308135336276614282806444486645238749" + \
              "30358907296290491560440772390713810515859307960866" + \
              "70172427121883998797908792274921901699720888093776" + \
              "65727333001053367881220235421809751254540594752243" + \
              "52584907711670556013604839586446706324415722155397" + \
              "53697817977846174064955149290862569321978468622482" + \
              "83972241375657056057490261407972968652414535100474" + \
              "82166370484403199890008895243450658541227588666881" + \
              "16427171479924442928230863465674813919123162824586" + \
              "17866458359124566529476545682848912883142607690042" + \
              "24219022671055626321111109370544217506941658960408" + \
              "07198403850962455444362981230987879927244284909188" + \
              "84580156166097919133875499200524063689912560717606" + \
              "05886116467109405077541002256983155200055935729725" + \
              "71636269561882670428252483600823257530420752963450"

    cur_max = 0
    for i in range(0, len(num_str) - num_digits + 1):
        temp_num = num_str[i: i + num_digits]
        if "0" not in temp_num:
            new_num = numpy.prod([int(i) for i in temp_num])
            if new_num > cur_max:
                cur_max = new_num
    return cur_max


def problem_009(sum_of=1000):
    """
    A Pythagorean triplet is a set of three natural numbers, a < b < c,
    for which,

    a2 + b2 = c2
    For example, 32 + 42 = 9 + 16 = 25 = 52.

    There exists exactly one Pythagorean triplet for
    which a + b + c = 1000.

    Find the product abc.
    """
    checked = 0
    for i in range(1, int(sum_of / 3)):
        for j in range(i + 1, 1 + int((sum_of - i) / 2)):
            for k in range(j + 1, 1 + int(sum_of - i - j)):
                checked += 1
                if i + j + k == sum_of:
                    if i * i + j * j == k * k:
                        return i * j * k


def problem_010(prime_below=2000000):
    """
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

    Find the sum of all the primes below two million.
    """
    return sum(_get_all_primes(prime_below)) - 1


def _get_all_primes(prime_below):
    primes = list(range(0, prime_below))
    p = 2
    inc = 1
    while True:
        for index in range(p ** 2, len(primes), inc * p):
            primes[index] = 0
        for i in range(p+1, int(prime_below ** (0.5))):
            if primes[i] != 0:
                inc = 2
                p = primes[i]
                break
        else:
            return primes


def _is_prime(num):
    factors = _get_factors(num)
    return len(factors) == 1


def _is_prime_quick(num):
    num_str = str(num)
    if len(num_str) > 1:
        if num_str[-1] in '024568':
            return False
    for i in _drange(2, (num / 2) + 1):
        if num % i == 0:
            return False
    return True


def _get_factors(num):
    factors = [(1, num)]
    for i in _drange(2, (num / 2) + 1):
        div = num / i
        if num % i == 0:
            if i == factors[-1][1]:
                break
            factors.append((i, div))
            if i == div:
                break
    return factors


def _drange(start, stop, step=1):
    r = start
    while r < stop:
        yield r
        r += step


def _build_fib(max_num):
    fib = [1, 2]
    while fib[-1] < max_num:
        fib.append(fib[-1] + fib[-2])
    return fib[0:-1]


def _divisible_by(num, div):
    a = num / float(div)
    return a == int(a)


if __name__ == "__main__":
    me = _sys.modules[__name__]
    if len(_sys.argv) > 1:
        item = getattr(me, _sys.argv[1])
        print "%s: %d" % (_sys.argv[1], item())
        _sys.exit(0)
    times = _LapWatch()
    for i in dir(me):

        if i[0] != "_":
            item = getattr(me, i)
            item_v2 = None
            try:
                item_v2 = getattr(me, i + "_v2")
            except:
                pass
            if callable(item):
                if callable(item_v2):
                    pass
                else:
                    print "{:14}: {:13} in {} sec".format(i, item(), times.lap(i))
                    times.lap(i)
    print "\n{:14}: {} sec".format("Total Time", times.elapsed)
